from __future__ import annotations

import ast
import atexit
import copy
import functools
import importlib.util
import inspect
import itertools
import logging
import pathlib
import shutil
import tempfile
from dataclasses import dataclass, field
from functools import lru_cache
from types import ModuleType
from typing import TYPE_CHECKING

import mako.template
from appdirs import AppDirs
from tokenize_rt import Offset, reversed_enumerate, src_to_tokens, tokens_to_src

from .compat import path_with_stem

if TYPE_CHECKING:
    from typing import Any

    from typing_extensions import Literal, Self

cache_dir = pathlib.Path(AppDirs("pytest-factoryboy").user_cache_dir)

logger = logging.getLogger(__name__)


@dataclass
class FixtureDef:
    name: str
    function_name: Literal["model_fixture", "attr_fixture", "factory_fixture", "subfactory_fixture"]
    function_kwargs: dict[str, Any] = field(default_factory=dict)
    deps: list[str] = field(default_factory=list)
    related: list[str] = field(default_factory=list)

    @property
    def kwargs_var_name(self):
        return f"_{self.name}__kwargs"


module_template = mako.template.Template(
    """\
import pytest
from pytest_factoryboy.fixture import (
    attr_fixture,
    factory_fixture,
    model_fixture,
    subfactory_fixture,
)


def _fixture(related):
    def fixture_maker(fn):
        fn._factoryboy_related = related
        return pytest.fixture(fn)

    return fixture_maker
% for fixture_def in fixture_defs:


${ fixture_def.kwargs_var_name } = {}


@_fixture(related=${ repr(fixture_def.related) })
def ${ fixture_def.name }(
% for dep in ["request"] + fixture_def.deps:
    ${ dep },
% endfor
):
    return ${ fixture_def.function_name }(request, **${ fixture_def.kwargs_var_name })
% endfor
"""
)

init_py_content = '''\
"""Pytest-factoryboy generated fixtures.

This module and the other modules in this package are automatically generated by
pytest-factoryboy. They will be rewritten on the next run.

"""
'''


@lru_cache()  # This way we reuse the same folder for the whole execution of the program
def make_temp_folder(package_name: str) -> pathlib.Path:
    """Create a temporary folder and automatically delete it when the process exit."""
    path = pathlib.Path(tempfile.mkdtemp()) / package_name
    path.mkdir(parents=True, exist_ok=True)

    atexit.register(shutil.rmtree, str(path))

    return path


@lru_cache()  # This way we reuse the same folder for the whole execution of the program
def create_package(package_name: str, init_py_content=init_py_content) -> pathlib.Path:
    path = cache_dir / package_name
    try:
        if path.exists():
            shutil.rmtree(str(path))

        path.mkdir(parents=True, exist_ok=False)
    except OSError:  # Catch cases where the directory can't be removed or can't be created
        logger.warning(f"Can't create the cache directory {path}. Using a temporary directory instead.", exc_info=True)
        return make_temp_folder(package_name)

    (path / "__init__.py").write_text(init_py_content)

    return path


def make_module(code: str, module_name: str, package_name: str) -> ModuleType:
    tmp_module_path = create_package(package_name) / f"{module_name}.py"

    counter = itertools.count(1)
    stem = tmp_module_path.stem
    while tmp_module_path.exists():
        count = next(counter)
        new_stem = f"{stem}_{count}"
        tmp_module_path = path_with_stem(tmp_module_path, new_stem)

    logger.info(f"Writing content of {module_name!r} into {tmp_module_path}.")

    tmp_module_path.write_text(code)
    name = f"{package_name}.{module_name}"
    spec = importlib.util.spec_from_file_location(name, tmp_module_path)
    assert spec  # NOTE: satisfy `mypy`
    mod = importlib.util.module_from_spec(spec)
    assert spec.loader  # NOTE: satisfy `mypy`
    spec.loader.exec_module(mod)
    return mod


def make_fixture_model_module(model_name, fixture_defs: list[FixtureDef]):
    code = module_template.render(fixture_defs=fixture_defs)
    generated_module = make_module(code, module_name=model_name, package_name="_pytest_factoryboy_generated_fixtures")
    for fixture_def in fixture_defs:
        assert hasattr(generated_module, fixture_def.kwargs_var_name)
        setattr(generated_module, fixture_def.kwargs_var_name, fixture_def.function_kwargs)
    return generated_module


def pop_kwarg(node: ast.Call, key: str) -> ast.Expr | None:
    for i, arg in enumerate(node.keywords):
        if isinstance(arg, ast.keyword) and arg.arg == key:
            node.keywords.pop(i)
            return arg.value
    return None


def rewrite_register_node(node: ast.Call) -> str | None:
    node = copy.copy(node)
    kwargs_names = {k.arg for k in node.keywords}
    unknown_kwargs = kwargs_names - {"factory_class", "name", "factory_kwargs"}

    if "factory_kwargs" in kwargs_names:
        raise ValueError("Cannot fix a function that uses both factory_kwargs and **kwargs")

    if len(node.args) < 2 and "_name" in unknown_kwargs:
        name = pop_kwarg(node, "_name")
        unknown_kwargs -= {"_name"}
        if name is not None:
            node.keywords.insert(0, ast.keyword("name", name))

    factory_kwargs = {}
    for kwarg in node.keywords:
        if kwarg.arg not in unknown_kwargs:
            continue
        factory_kwargs[kwarg.arg] = pop_kwarg(node, kwarg.arg)

    factory_kwargs_node = ast.Expr(value=ast.Dict(keys=[], values=[]))
    for key, value in factory_kwargs.items():
        factory_kwargs_node.value.keys.append(ast.Str(s=key))
        factory_kwargs_node.value.values.append(value)

    if factory_kwargs:
        node.keywords.append(ast.keyword("factory_kwargs", factory_kwargs_node))
    source = ast.unparse(node)
    return source


@dataclass
class DecoratorInfo:
    node: ast.Call
    offset_start: Offset
    offset_end: Offset

    @classmethod
    def from_node(cls, node: ast.Call) -> Self:
        return cls(
            node=node,
            offset_start=Offset(node.lineno, node.col_offset),
            offset_end=Offset(node.end_lineno, node.end_col_offset),
        )


def upgrade_source(source: str, source_filename: str) -> str:
    tree = ast.parse(source, filename=source_filename)
    found: list[DecoratorInfo] = []
    for node in ast.walk(tree):
        if isinstance(node, ast.ClassDef):
            for decorator in node.decorator_list:
                if not isinstance(decorator, ast.Call):
                    continue
                func = decorator.func
                if not isinstance(func, ast.Name):
                    # TODO: implement this case
                    raise NotImplementedError
                if func.id != "register":
                    continue
                found.append(DecoratorInfo.from_node(decorator))
        elif isinstance(node, ast.Call):
            func = node.func
            if not isinstance(func, ast.Name):
                # TODO: implement this case
                raise NotImplementedError
            if func.id != "register":
                continue
            found.append(DecoratorInfo.from_node(node))

    found_by_start_offset: dict[Offset, DecoratorInfo] = {dec_info.offset_start: dec_info for dec_info in found}
    tokens = src_to_tokens(source)
    for i, token in reversed_enumerate(tokens):
        if (dec_info := found_by_start_offset.get(token.offset)) is None:
            continue

        if not token.src:
            # skip possible DEDENT tokens
            continue

        end_token_pos = next(i for i, t in reversed_enumerate(tokens) if t.offset == dec_info.offset_end)
        new_decorator = rewrite_register_node(dec_info.node)
        if new_decorator is not None:
            tokens[i:end_token_pos] = [tokens[i]._replace(src=new_decorator)]
    new_source = tokens_to_src(tokens)
    return new_source


@functools.lru_cache()  # So that we rewrite each file only once
def upgrade_module(module: ModuleType) -> None:
    # TODO: Double check that module.__file__ is always accessible. Maybe it wasn't always an absolute path
    # TODO: Handle case where module.__file__ or module.__source__ is not accessible
    source = inspect.getsource(module)
    source_filename = inspect.getsourcefile(module)
    new_source = upgrade_source(source=source, source_filename=source_filename)

    source_file = pathlib.Path(source_filename)
    new_source_file = source_file.with_stem(source_file.stem + "_upgraded")
    new_source_file.write_text(new_source)
