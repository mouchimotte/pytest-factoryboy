from __future__ import annotations

import ast
import atexit
import copy
import functools
import importlib.util
import inspect
import itertools
import logging
import pathlib
import shutil
import tempfile
from collections import defaultdict
from dataclasses import dataclass, field
from functools import lru_cache
from types import ModuleType
from typing import TYPE_CHECKING, Container

import mako.template
from appdirs import AppDirs
from tokenize_rt import Offset, reversed_enumerate, src_to_tokens, tokens_to_src

from .compat import path_with_stem

if TYPE_CHECKING:
    from typing import Any

    from typing_extensions import Literal, Self

cache_dir = pathlib.Path(AppDirs("pytest-factoryboy").user_cache_dir)

logger = logging.getLogger(__name__)


@dataclass
class FixtureDef:
    name: str
    function_name: Literal["model_fixture", "attr_fixture", "factory_fixture", "subfactory_fixture"]
    function_kwargs: dict[str, Any] = field(default_factory=dict)
    deps: list[str] = field(default_factory=list)
    related: list[str] = field(default_factory=list)

    @property
    def kwargs_var_name(self):
        return f"_{self.name}__kwargs"


module_template = mako.template.Template(
    """\
import pytest
from pytest_factoryboy.fixture import (
    attr_fixture,
    factory_fixture,
    model_fixture,
    subfactory_fixture,
)


def _fixture(related):
    def fixture_maker(fn):
        fn._factoryboy_related = related
        return pytest.fixture(fn)

    return fixture_maker
% for fixture_def in fixture_defs:


${ fixture_def.kwargs_var_name } = {}


@_fixture(related=${ repr(fixture_def.related) })
def ${ fixture_def.name }(
% for dep in ["request"] + fixture_def.deps:
    ${ dep },
% endfor
):
    return ${ fixture_def.function_name }(request, **${ fixture_def.kwargs_var_name })
% endfor
"""
)

init_py_content = '''\
"""Pytest-factoryboy generated fixtures.

This module and the other modules in this package are automatically generated by
pytest-factoryboy. They will be rewritten on the next run.

"""
'''


@lru_cache()  # This way we reuse the same folder for the whole execution of the program
def make_temp_folder(package_name: str) -> pathlib.Path:
    """Create a temporary folder and automatically delete it when the process exit."""
    path = pathlib.Path(tempfile.mkdtemp()) / package_name
    path.mkdir(parents=True, exist_ok=True)

    atexit.register(shutil.rmtree, str(path))

    return path


@lru_cache()  # This way we reuse the same folder for the whole execution of the program
def create_package(package_name: str, init_py_content=init_py_content) -> pathlib.Path:
    path = cache_dir / package_name
    try:
        if path.exists():
            shutil.rmtree(str(path))

        path.mkdir(parents=True, exist_ok=False)
    except OSError:  # Catch cases where the directory can't be removed or can't be created
        logger.warning(f"Can't create the cache directory {path}. Using a temporary directory instead.", exc_info=True)
        return make_temp_folder(package_name)

    (path / "__init__.py").write_text(init_py_content)

    return path


def make_module(code: str, module_name: str, package_name: str) -> ModuleType:
    tmp_module_path = create_package(package_name) / f"{module_name}.py"

    counter = itertools.count(1)
    stem = tmp_module_path.stem
    while tmp_module_path.exists():
        count = next(counter)
        new_stem = f"{stem}_{count}"
        tmp_module_path = path_with_stem(tmp_module_path, new_stem)

    logger.info(f"Writing content of {module_name!r} into {tmp_module_path}.")

    tmp_module_path.write_text(code)
    name = f"{package_name}.{module_name}"
    spec = importlib.util.spec_from_file_location(name, tmp_module_path)
    assert spec  # NOTE: satisfy `mypy`
    mod = importlib.util.module_from_spec(spec)
    assert spec.loader  # NOTE: satisfy `mypy`
    spec.loader.exec_module(mod)
    return mod


def make_fixture_model_module(model_name, fixture_defs: list[FixtureDef]):
    code = module_template.render(fixture_defs=fixture_defs)
    generated_module = make_module(code, module_name=model_name, package_name="_pytest_factoryboy_generated_fixtures")
    for fixture_def in fixture_defs:
        assert hasattr(generated_module, fixture_def.kwargs_var_name)
        setattr(generated_module, fixture_def.kwargs_var_name, fixture_def.function_kwargs)
    return generated_module


# copied from pyupgrade:
# https://github.com/asottile/pyupgrade/blob/75f5b9eaf80353346d1ccb36171ff8426307d5fe/pyupgrade/_ast_helpers.py#L21
def is_name_attr(
    node: ast.AST,
    imports: dict[str, set[str]],
    mods: tuple[str, ...],
    names: Container[str],
) -> bool:
    return (isinstance(node, ast.Name) and node.id in names and any(node.id in imports[mod] for mod in mods)) or (
        isinstance(node, ast.Attribute)
        and isinstance(node.value, ast.Name)
        and node.value.id in mods
        and node.attr in names
    )


def rewrite_register_node(
    node: ast.Call, new_name_param="name", new_factory_kwargs_param="factory_kwargs"
) -> str | None:
    node = copy.deepcopy(node)

    new_node_keywords = []

    # For debugging purposes
    node_str = ast.unparse(node)  # noqa

    kwargs_names = {k.arg for k in node.keywords}

    if new_factory_kwargs_param not in kwargs_names:

        factory_kwargs_keyword = {}

        for kwarg in node.keywords:
            key = kwarg.arg
            value = kwarg.value
            if key == "factory_class":
                continue

            # Fix #1: _name -> name
            if key == "_name":
                name_kwarg = copy.deepcopy(kwarg)
                name_kwarg.arg = new_name_param
                new_node_keywords.append(name_kwarg)
                continue

            # Fix #2: foo=bar, **kwargs -> factory_kwargs={...}
            if key is not None:
                # the argument is a "foo="bar" style keyword argument
                key = ast.Str(s=key)
            # otherwise it's a "**kwargs"

            factory_kwargs_keyword[key] = value

        if factory_kwargs_keyword:
            keys, values = zip(*factory_kwargs_keyword.items())
            factory_kwargs_node = ast.Expr(value=ast.Dict(keys=keys, values=values))
            new_node_keywords.append(ast.keyword(new_factory_kwargs_param, factory_kwargs_node))

    node.keywords = new_node_keywords

    source = ast.unparse(node)
    return source


@dataclass
class DecoratorInfo:
    node: ast.Call
    offset_start: Offset
    offset_end: Offset

    @classmethod
    def from_node(cls, node: ast.Call) -> Self:
        return cls(
            node=node,
            offset_start=Offset(node.lineno, node.col_offset),
            offset_end=Offset(node.end_lineno, node.end_col_offset),
        )


def upgrade_source(source: str, source_filename: str) -> str:
    tree = ast.parse(source, filename=source_filename)
    found: list[DecoratorInfo] = []
    from_imports: dict[str, set] = defaultdict(set)
    for node in ast.walk(tree):
        if isinstance(node, ast.ImportFrom) and not node.level and node.module in ["pytest_factoryboy"]:
            from_imports[node.module].update(name.name for name in node.names if not name.asname)

        elif isinstance(node, ast.Call):
            func = node.func
            if is_name_attr(
                func,
                from_imports,
                ("pytest_factoryboy",),
                ("register",),
            ):
                print(f"Found register call at {node.lineno}:{node.col_offset}. {ast.unparse(node)}")
                found.append(DecoratorInfo.from_node(node))

    found_by_start_offset: dict[Offset, DecoratorInfo] = {dec_info.offset_start: dec_info for dec_info in found}
    tokens = src_to_tokens(source)
    for i, token in reversed_enumerate(tokens):
        if (dec_info := found_by_start_offset.get(token.offset)) is None:
            continue

        if not token.src:
            # skip possible DEDENT tokens
            continue

        end_token_pos = next(i for i, t in reversed_enumerate(tokens) if t.offset == dec_info.offset_end)
        new_call = rewrite_register_node(dec_info.node)
        if new_call is not None:
            tokens[i:end_token_pos] = [tokens[i]._replace(src=new_call)]
    new_source = tokens_to_src(tokens)
    return new_source


@functools.lru_cache()  # So that we rewrite each file only once
def upgrade_module(module: ModuleType) -> None:
    # TODO: Double check that module.__file__ is always accessible. Maybe it wasn't always an absolute path
    # TODO: Handle case where module.__file__ or module.__source__ is not accessible
    source = inspect.getsource(module)
    source_filename = inspect.getsourcefile(module)
    new_source = upgrade_source(source=source, source_filename=source_filename)

    source_file = pathlib.Path(source_filename)
    new_source_file = source_file.with_stem(source_file.stem + "_upgraded")
    new_source_file.write_text(new_source)
