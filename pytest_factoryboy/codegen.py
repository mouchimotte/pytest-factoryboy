from __future__ import annotations

import ast
import atexit
import copy
import functools
import importlib.util
import inspect
import itertools
import logging
import pathlib
import shutil
import tempfile
from collections import defaultdict
from dataclasses import dataclass, field
from functools import lru_cache
from types import ModuleType
from typing import TYPE_CHECKING

import mako.template
from appdirs import AppDirs

# TODO: Remove pyupgrade usage
from pyupgrade._ast_helpers import is_name_attr
from tokenize_rt import Offset, reversed_enumerate, src_to_tokens, tokens_to_src

from .compat import path_with_stem

if TYPE_CHECKING:
    from typing import Any

    from typing_extensions import Literal, Self

cache_dir = pathlib.Path(AppDirs("pytest-factoryboy").user_cache_dir)

logger = logging.getLogger(__name__)


@dataclass
class FixtureDef:
    name: str
    function_name: Literal["model_fixture", "attr_fixture", "factory_fixture", "subfactory_fixture"]
    function_kwargs: dict[str, Any] = field(default_factory=dict)
    deps: list[str] = field(default_factory=list)
    related: list[str] = field(default_factory=list)

    @property
    def kwargs_var_name(self):
        return f"_{self.name}__kwargs"


module_template = mako.template.Template(
    """\
import pytest
from pytest_factoryboy.fixture import (
    attr_fixture,
    factory_fixture,
    model_fixture,
    subfactory_fixture,
)


def _fixture(related):
    def fixture_maker(fn):
        fn._factoryboy_related = related
        return pytest.fixture(fn)

    return fixture_maker
% for fixture_def in fixture_defs:


${ fixture_def.kwargs_var_name } = {}


@_fixture(related=${ repr(fixture_def.related) })
def ${ fixture_def.name }(
% for dep in ["request"] + fixture_def.deps:
    ${ dep },
% endfor
):
    return ${ fixture_def.function_name }(request, **${ fixture_def.kwargs_var_name })
% endfor
"""
)

init_py_content = '''\
"""Pytest-factoryboy generated fixtures.

This module and the other modules in this package are automatically generated by
pytest-factoryboy. They will be rewritten on the next run.

"""
'''


@lru_cache()  # This way we reuse the same folder for the whole execution of the program
def make_temp_folder(package_name: str) -> pathlib.Path:
    """Create a temporary folder and automatically delete it when the process exit."""
    path = pathlib.Path(tempfile.mkdtemp()) / package_name
    path.mkdir(parents=True, exist_ok=True)

    atexit.register(shutil.rmtree, str(path))

    return path


@lru_cache()  # This way we reuse the same folder for the whole execution of the program
def create_package(package_name: str, init_py_content=init_py_content) -> pathlib.Path:
    path = cache_dir / package_name
    try:
        if path.exists():
            shutil.rmtree(str(path))

        path.mkdir(parents=True, exist_ok=False)
    except OSError:  # Catch cases where the directory can't be removed or can't be created
        logger.warning(f"Can't create the cache directory {path}. Using a temporary directory instead.", exc_info=True)
        return make_temp_folder(package_name)

    (path / "__init__.py").write_text(init_py_content)

    return path


def make_module(code: str, module_name: str, package_name: str) -> ModuleType:
    tmp_module_path = create_package(package_name) / f"{module_name}.py"

    counter = itertools.count(1)
    stem = tmp_module_path.stem
    while tmp_module_path.exists():
        count = next(counter)
        new_stem = f"{stem}_{count}"
        tmp_module_path = path_with_stem(tmp_module_path, new_stem)

    logger.info(f"Writing content of {module_name!r} into {tmp_module_path}.")

    tmp_module_path.write_text(code)
    name = f"{package_name}.{module_name}"
    spec = importlib.util.spec_from_file_location(name, tmp_module_path)
    assert spec  # NOTE: satisfy `mypy`
    mod = importlib.util.module_from_spec(spec)
    assert spec.loader  # NOTE: satisfy `mypy`
    spec.loader.exec_module(mod)
    return mod


def make_fixture_model_module(model_name, fixture_defs: list[FixtureDef]):
    code = module_template.render(fixture_defs=fixture_defs)
    generated_module = make_module(code, module_name=model_name, package_name="_pytest_factoryboy_generated_fixtures")
    for fixture_def in fixture_defs:
        assert hasattr(generated_module, fixture_def.kwargs_var_name)
        setattr(generated_module, fixture_def.kwargs_var_name, fixture_def.function_kwargs)
    return generated_module


def pop_kwarg(node: ast.Call, key: str) -> ast.Expr | None:
    for i, arg in enumerate(node.keywords):
        if isinstance(arg, ast.keyword) and arg.arg == key:
            node.keywords.pop(i)
            return arg.value
    return None


def replace_keyword(node: ast.Call, key: str, new_key: str) -> None:
    for keyword in node.keywords:
        if isinstance(keyword, ast.keyword) and keyword.arg == key:
            keyword.arg = new_key
            return
    raise ValueError(f"Keyword {key} not found in {node}")


def rewrite_register_node(node: ast.Call) -> str | None:
    node = copy.copy(node)

    # For debugging purposes
    node_str = ast.unparse(node)  # noqa
    kwargs_names = {k.arg for k in node.keywords}

    # Fix #1: _name -> name
    if "_name" in kwargs_names:
        replace_keyword(node, "_name", "name")

    if "factory_kwargs" not in kwargs_names:

        # Fix #2: **kwargs -> factory_kwargs
        factory_kwargs = {}
        for kwarg in node.keywords:
            if kwarg.arg == "factory_class":
                continue
            factory_kwargs[kwarg.arg] = pop_kwarg(node, kwarg.arg)

        factory_kwargs_node = ast.Expr(value=ast.Dict(keys=[], values=[]))
        for key, value in factory_kwargs.items():
            factory_kwargs_node.value.keys.append(ast.Str(s=key))
            factory_kwargs_node.value.values.append(value)

        if factory_kwargs:
            node.keywords.append(ast.keyword("factory_kwargs", factory_kwargs_node))

    source = ast.unparse(node)
    return source


@dataclass
class DecoratorInfo:
    node: ast.Call
    offset_start: Offset
    offset_end: Offset

    @classmethod
    def from_node(cls, node: ast.Call) -> Self:
        return cls(
            node=node,
            offset_start=Offset(node.lineno, node.col_offset),
            offset_end=Offset(node.end_lineno, node.end_col_offset),
        )


def upgrade_source(source: str, source_filename: str) -> str:
    tree = ast.parse(source, filename=source_filename)
    found: list[DecoratorInfo] = []
    from_imports: dict[str, set] = defaultdict(set)
    for node in ast.walk(tree):
        if isinstance(node, ast.ImportFrom) and not node.level and node.module in ["pytest_factoryboy"]:
            from_imports[node.module].update(name.name for name in node.names if not name.asname)

        elif isinstance(node, ast.Call):
            func = node.func
            if is_name_attr(
                func,
                from_imports,
                ("pytest_factoryboy",),
                ("register",),
            ):
                print(f"Found register call at {node.lineno}:{node.col_offset}. {ast.unparse(node)}")
                found.append(DecoratorInfo.from_node(node))

    found_by_start_offset: dict[Offset, DecoratorInfo] = {dec_info.offset_start: dec_info for dec_info in found}
    tokens = src_to_tokens(source)
    for i, token in reversed_enumerate(tokens):
        if (dec_info := found_by_start_offset.get(token.offset)) is None:
            continue

        if not token.src:
            # skip possible DEDENT tokens
            continue

        end_token_pos = next(i for i, t in reversed_enumerate(tokens) if t.offset == dec_info.offset_end)
        new_call = rewrite_register_node(dec_info.node)
        if new_call is not None:
            tokens[i:end_token_pos] = [tokens[i]._replace(src=new_call)]
    new_source = tokens_to_src(tokens)
    return new_source


@functools.lru_cache()  # So that we rewrite each file only once
def upgrade_module(module: ModuleType) -> None:
    # TODO: Double check that module.__file__ is always accessible. Maybe it wasn't always an absolute path
    # TODO: Handle case where module.__file__ or module.__source__ is not accessible
    source = inspect.getsource(module)
    source_filename = inspect.getsourcefile(module)
    new_source = upgrade_source(source=source, source_filename=source_filename)

    source_file = pathlib.Path(source_filename)
    new_source_file = source_file.with_stem(source_file.stem + "_upgraded")
    new_source_file.write_text(new_source)
